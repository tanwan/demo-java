plugins {
    id 'groovy'
    id 'java-gradle-plugin'
}

dependencies {
    //gradle plugin使用的是groovy3
    testImplementation group: 'org.spockframework', name: 'spock-core', version: '2.3-groovy-3.0'
}

test {
    onlyIf { false }
}

// gradle如果只在一个项目中使用的话,可以直接使用buildSrc(https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources)
gradlePlugin {
    plugins {
        simpleGroovyPlugin {
            id = 'com.lzy.demo.simple-groovy-plugin'
            implementationClass = 'com.lzy.demo.gradle.plugin.SimpleGroovyPlugin'
        }
        simpleJavaPlugin {
            id = 'com.lzy.demo.simple-java-plugin'
            implementationClass = 'com.lzy.demo.gradle.plugin.SimpleJavaPlugin'
        }
    }
}

//这边使用idea-ext来配置
rootProject.idea.project.settings {
    taskTriggers {
        //pluginUnderTestMetadata是java-gradle-plugin的task,用来生成plugin-under-test-metadata.properties
        beforeBuild pluginUnderTestMetadata
    }
}

//这边就是全部交给groovy去处理,这样java就可以直接调用到groovy的类
sourceSets {
    main {
        groovy {
            srcDirs += sourceSets.main.java.srcDirs
        }
        java {
            srcDirs = []
        }
    }
}

//task publish<pluginName>PluginMarkerMavenPublicationToMavenLocal会发布一个.plugin文件到本地仓库,此文件只是一个pom文件, 记录plugin的gav坐标
//task publishToMavenLocal是将plugin打成jar包发布到本地仓库
//需要同时存在.plugin文件和jar,此plugin才能被应用
publishing {
    publications {
        //java-gradle-plugin会创造出pluginMaven这个publication
        //see build.gradle的publishing
        pluginMaven(MavenPublication) {
            //如果项目使用了bom,就需要这边的配置从runtime的classpath解析出依赖的版本
            //如果在dependencies{}块中显式的指定了版本,那么就不需要这边的配置
            versionMapping {
                usage('java-api') {
                    fromResolutionOf('runtimeClasspath')
                }
                usage('java-runtime') {
                    fromResolutionResult()
                }
            }
        }
    }
}